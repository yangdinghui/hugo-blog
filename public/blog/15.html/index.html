<!DOCTYPE html>
<html lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.135.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="halo" />
<meta property="og:url" content="http://localhost:1313/blog/15.html/" />
<link rel="canonical" href="http://localhost:1313/blog/15.html/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon.ico" /><link rel="alternate" type="application/atom+xml" href="http://localhost:1313/index.xml" title="halo的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "http:\/\/localhost:1313\/"
},
"articleSection" : "blog",
"name" : "面向对象编程",
"headline" : "面向对象编程",
"description" : "面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。\n一、什么是面向对象编程 js 是基于原型的，基于面向对象编程\n面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类\n1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。\n自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用\n面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。\n2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统\n面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。\n想要弄明白面向对象，需要先理解类和对象的概念\n《什么是类和对象？》\n二、创建对象的方法 1.创建字面量和实例 window.onload = function() { \/\/ 实例 var person = new Object(); person.name = \u0026#39;小明\u0026#39;; person.age = 22; person.year = function() { console.log(this.name \u002b \u0026#39;今年\u0026#39; \u002b this.age \u002b \u0026#39;岁了！\u0026#39;) }; person.year(); \/\/ 字面量 var student = { name: \u0026#39;小明\u0026#39;, age: 22, year: function () { console.log(this.name \u002b \u0026#39;今年\u0026#39; \u002b this.age \u002b \u0026#39;岁了！\u0026#39;) } } student.year(); } \/\/ 小明今年22岁了！ 两者输出的结果是一样的，控制台输出：\n缺点：重复实例化对象，代码冗余高\n2.工厂模式 window.onload = function() { function createObj(name, age) { var obj = new Object(); obj.name = name, obj.age = age, obj.year = function() { console.log(this.name \u002b \u0026#39;今年\u0026#39; \u002b this.age \u002b \u0026#39;岁了！\u0026#39;) } return obj; } var obj = createObj(\u0026#39;小明\u0026#39;, 22); obj.year(); } \/\/ 小明今年22岁了！ 优点：解决重复实例化对象的问题 缺点：无法识别对象的类型，因为所有的实例都指向一个原型\n3.构造函数 window.onload = function() { function Person(name, age) { this.name = name; this.age = age; this.year = function() { console.log(this.name \u002b \u0026#39;今年\u0026#39; \u002b this.age \u002b \u0026#39;岁了！\u0026#39;) } } var student = new Person(\u0026#39;小明\u0026#39;, 22); student.year(); } \/\/ 小明今年22岁了！ 优点：可以识别对象的类型 缺点：多个实例重复创建方法，无法共享\n4. 原型模式 window.onload = function() { function Par() {} Par.prototype = { constructor: \u0026#39;Par\u0026#39;, name: \u0026#39;小明\u0026#39;, age: 22, year: function() { console.log(this.name \u002b \u0026#39;今年\u0026#39; \u002b this.age \u002b \u0026#39;岁了！\u0026#39;) } }; var son = new Par(); son.year(); } \/\/ 小明今年22岁了！ 缺点：所有实例共享他的属性和方法，不能传参和初始化属性值\n5.混合模式 (推荐使用) 是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值\n先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过 prototype 获取，有一个 constructor 属性，可以指向要操作的函数对象（构造函数）\n比如constructor: Par，就代表下面这个原型方法指向Par()对象（构造函数）\nwindow.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name \u002b \u0026#39;今年\u0026#39; \u002b this.age \u002b \u0026#39;岁了！\u0026#39;); } }; var son = new Par(\u0026#39;小明\u0026#39;, 22) son.year(); } \/\/ 小明今年22岁了！ 三、原型，原型链 1.原型对象 函数对象都具有prototype属性，它指向函数的原型对象 (浏览器内存创建的对象)，原型对象都具有constructor属性，它指向prototype属性所在的函数对象 (构造函数) window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { \/\/ constructor指向对象 constructor: Par, year: function() { console.log(this.name \u002b \u0026#39;今年\u0026#39; \u002b this.age \u002b \u0026#39;岁了！\u0026#39;); } }; var son = new Par(\u0026#39;小明\u0026#39;, 22) son.year(); \/*********************************************\/ console.log(Par.prototype) console.log(Par.prototype.constructor) \/*********************************************\/ } 通过控制台可以看到\n构造函数的prototypr属性指向原型对象\n原型对象的construcyor属性指向构造函数\n当调用构造函数创建一个实例后，该实例会有一个隐藏属性__proto__ ，它指向构造函数的原型对象 console.log(son.__proto__ === Par.prototype) \/\/ true 所有的构造函数的 prototype 都是 object 类型 console.log(typeof Par.prototype) \/\/ object Function 的 prototype 是一个空函数，所有内置函数的__proto__属性都指向这个空函数 console.log(Math.__proto__) 如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过delete方法将同名属性在实例（构造函数）中彻底删除 window.onload = function () { function Par(name) { this.name = name; } Par.prototype.name = \u0026#34;张三\u0026#34;; var son = new Par(\u0026#34;李四\u0026#34;); console.log(son.name); \/\/ 李四 console.log(son.__proto__.name); \/\/ 张三 \/\/ 使用 delete 删除实例的同名属性值 console.log(delete son.name); \/\/ true console.log(son.name); \/\/ 张三 } 通过hasOwnProperty(属性名)可以判断一个属性存在于构造函数中，还是原型对象中 true表示存在构造函数中；false表示存在原型对象中\nconsole.log(Par.hasOwnProperty(name)); \/\/ false 操作符in，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可） window.onload = function () { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name \u002b this.age) } }; var son = new Par(\u0026#39;xm\u0026#39;, \u0026#39;22\u0026#39;) son.year(); console.log(\u0026#39;name\u0026#39; in Par); \/\/ true console.log(\u0026#39;age\u0026#39; in Par); \/\/ false } 同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样\n参考:《对象中是否有某一个属性 in》https:\/\/www.cnblogs.com\/IwishIcould\/p\/12333739.html\n2.__proto__和 prototype 的区别 prototype属性只有函数对象上才有，而__proto__属性所有对象都有\nprototype是由函数对象指向原型对象，而__proto__是由实例指向函数对象的原型对象\n原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做原型链\n3.继承 原型链继承 优点：父类原型定义的属性和方法可以复用 缺点：子类实例没有自己的属性，不能向父类传递参数\nfunction test1() { function SuperType() { this.city = [ \u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34; ]; this.property = true; } SuperType.prototype = { constructor : SuperType, \/\/ 保持构造函数和原型对象的完整性 age : 15, getSuperValue : function() { return this.property; } }; function SonType() { this.property = false; } \/\/ 重写子类的原型指向父类的实例：继承父类的原型 SubType.prototype = new SuperType(); SubType.prototype = { constructor : SubType, getSonType : function() { return this.property; } }; \/\/ 优点验证 let son = new SubType(); console.log(son.age); \/\/ 15 console.log(son.getSuperValue()); \/\/ false \/\/ 缺点验证 let instance1 = new SubType(); instance1.city.push(\u0026#34;重庆\u0026#34;); console.log(instance1.city); \/\/ [\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34;, \u0026#34;重庆\u0026#34;] let instance2 = new SubType(); console.log(instance2.city); \/\/ [\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34;, \u0026#34;重庆\u0026#34;] } \/\/ test1(); 构造函数继承 优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点 缺点：父类原型的属性和方法不可复用\nfunction test2() { function SuperType(name) { this.name = name; this.city = [ \u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34; ] } SuperType.prototype = { constructor : SuperType, age : 18, showInfo : function() { return this.name; } }; function SubType() { \/\/ 父类调用 call() 或者 apply() 方法和子类共用同一个 this，实现子类实例属性的继承 SuperType.call(this, \u0026#34;张三\u0026#34;); } \/\/ 优点验证 let instance = new SubType(); instance.city.push(\u0026#34;重庆\u0026#34;); console.log(instance.city); \/\/ [\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34;, \u0026#34;重庆\u0026#34;] let instance1 = new SubType(); console.log(instance1.city); \/\/ [\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34;] \/\/ 缺点验证 console.log(instance.age); \/\/ undefined instance.showInfo(); \/\/ son.showInfo is not a function } \/\/ test2(); 组合继承（推荐） 优点：原型的属性和方法可以复用，每个子类实例都有自己的属性 缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖\nfunction test3() { function SuperType(name) { this.name = name; this.city = [ \u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34; ] } SuperType.prototype = { constructor : SuperType, showInfo : function() { console.log(this.name \u002b \u0026#34;今年\u0026#34; \u002b this.age \u002b \u0026#34;岁了\u0026#34;); } }; function SubType(name, age) { \/\/ 1. 通过构造方法继承实现实例属性的继承 SuperType.call(this, name); this.age = age; } \/\/ 2. 通过原型链继承实现原型方法的继承 SubType.prototype = new SuperType(); \/\/ 优点验证 let instance = new SubType(\u0026#34;张三\u0026#34;, 15); instance.showInfo(); \/\/ 张三今年 15 岁了 let instance1 = new SubType(); instance1.city.push(\u0026#34;重庆\u0026#34;); console.log(instance1.city); \/\/ [\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34;, \u0026#34;重庆\u0026#34;] let instance2 = new SubType(); console.log(instance2.city); \/\/ [\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34;] } \/\/ test3(); 寄生组合继承（推荐） 优点：解决了组合继承的缺点，效率高 缺点：基本没有\nfunction test4() { function inheritPrototype(subType, superType) { \/\/ 1. 继承父类的原型 var prototype = Object.create(superType.prototype); \/\/ 2. 重写被污染的 construct prototype.constructor = subType; \/\/ 3. 重写子类的原型 subType.prototype = prototype; } function SuperType(name) { this.name = name; this.city = [ \u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34; ]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } \/\/ 将父类原型指向子类 inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() { console.log(this.age); } \/\/ 优点验证 let instance = new SubType(\u0026#34;张三\u0026#34;, 15); instance.sayName(); \/\/ 张三 let instance1 = new SubType(); instance1.city.push(\u0026#34;重庆\u0026#34;); console.log(instance1.city); \/\/ [\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34;, \u0026#34;重庆\u0026#34;] let instance2 = new SubType(); console.log(instance2.city); \/\/ [\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;天津\u0026#34;] } \/\/ test4(); 4.ES6 新方法－－class 新的关键字class在 es6 开始被引入到 javascript 中来，class的目的就是让定义类更简单\n用函数方法实现：\nfunction Person(name) { this.name = name; } Person.prototype.hello = function () { console.log(\u0026#39;Hello, \u0026#39; \u002b this.name \u002b \u0026#39;!\u0026#39;); } var son = new Person(\u0026#39;xm\u0026#39;) son.hello(); \/\/ Hello, xm! 用class来实现：\nclass Person { constructor(name) { this.name = name; } hello() { console.log(\u0026#39;Hello, \u0026#39; \u002b this.name \u002b \u0026#39;!\u0026#39;); } } var son = new person(\u0026#39;xm\u0026#39;) son.hello(); \/\/ Hello, xm! 可以在看到，在定义class中，直接包含了构造函数constructor属性，和原型对象上的函数hello()方法，省略掉了function关键字\n需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用class可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的\nclass 继承\n用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Person派生一个PrimaryPerson需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：\nclass PrimaryPerson extends Person { constructor(name, grade) { super(name); \/\/ 记得用 super 调用父类的构造方法！ this.grade = grade; } myGrade() { alert(\u0026#39;I am at grade \u0026#39; \u002b this.grade); } } 注意PrimaryPerson的定义也是通过 class 关键字实现的，而extends则表示原型链对象来自Person，子类的构造函数可能会和父类的不太相同\n例如，PrimaryPerson需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。\nPrimaryPerson已经自动获得了父类Person的hello方法，我们又在子类中定义了新的myGrade方法。\nES6 引入的class和原有的JavaScript原型继承有什么区别呢？\n实际上它们没有任何区别，class的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。\n但是！\n目前并不是所有的浏览器都支持class，所以在选择的时候一定要慎重！\n",
"inLanguage" : "en-US",
"author" : "halo",
"creator" : "halo",
"publisher": "halo",
"accountablePerson" : "halo",
"copyrightHolder" : "halo",
"copyrightYear" : "2020",
"datePublished": "2020-11-12 00:00:00 \u002b0000 UTC",
"dateModified" : "2020-11-12 00:00:00 \u002b0000 UTC",
"url" : "http:\/\/localhost:1313\/blog\/15.html\/",
"keywords" : [ "编程","js", ]
}
</script><title>面向对象编程 - halo的博客</title>
<meta property="og:title" content="面向对象编程" />
<meta property="og:type" content="article" />
<meta property="og:description" content="面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
一、什么是面向对象编程 js 是基于原型的，基于面向对象编程
面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类
1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。
自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用
面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。
2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统
面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
想要弄明白面向对象，需要先理解类和对象的概念
《什么是类和对象？》
二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = &#39;小明&#39;; person.age = 22; person.year = function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) }; person.year(); // 字面量 var student = { name: &#39;小明&#39;, age: 22, year: function () { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出：
缺点：重复实例化对象，代码冗余高
2.工厂模式 window.onload = function() { function createObj(name, age) { var obj = new Object(); obj.name = name, obj.age = age, obj.year = function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) } return obj; } var obj = createObj(&#39;小明&#39;, 22); obj.year(); } // 小明今年22岁了！ 优点：解决重复实例化对象的问题 缺点：无法识别对象的类型，因为所有的实例都指向一个原型
3.构造函数 window.onload = function() { function Person(name, age) { this.name = name; this.age = age; this.year = function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) } } var student = new Person(&#39;小明&#39;, 22); student.year(); } // 小明今年22岁了！ 优点：可以识别对象的类型 缺点：多个实例重复创建方法，无法共享
4. 原型模式 window.onload = function() { function Par() {} Par.prototype = { constructor: &#39;Par&#39;, name: &#39;小明&#39;, age: 22, year: function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) } }; var son = new Par(); son.year(); } // 小明今年22岁了！ 缺点：所有实例共享他的属性和方法，不能传参和初始化属性值
5.混合模式 (推荐使用) 是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值
先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过 prototype 获取，有一个 constructor 属性，可以指向要操作的函数对象（构造函数）
比如constructor: Par，就代表下面这个原型方法指向Par()对象（构造函数）
window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;); } }; var son = new Par(&#39;小明&#39;, 22) son.year(); } // 小明今年22岁了！ 三、原型，原型链 1.原型对象 函数对象都具有prototype属性，它指向函数的原型对象 (浏览器内存创建的对象)，原型对象都具有constructor属性，它指向prototype属性所在的函数对象 (构造函数) window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { // constructor指向对象 constructor: Par, year: function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;); } }; var son = new Par(&#39;小明&#39;, 22) son.year(); /*********************************************/ console.log(Par.prototype) console.log(Par.prototype.constructor) /*********************************************/ } 通过控制台可以看到
构造函数的prototypr属性指向原型对象
原型对象的construcyor属性指向构造函数
当调用构造函数创建一个实例后，该实例会有一个隐藏属性__proto__ ，它指向构造函数的原型对象 console.log(son.__proto__ === Par.prototype) // true 所有的构造函数的 prototype 都是 object 类型 console.log(typeof Par.prototype) // object Function 的 prototype 是一个空函数，所有内置函数的__proto__属性都指向这个空函数 console.log(Math.__proto__) 如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过delete方法将同名属性在实例（构造函数）中彻底删除 window.onload = function () { function Par(name) { this.name = name; } Par.prototype.name = &#34;张三&#34;; var son = new Par(&#34;李四&#34;); console.log(son.name); // 李四 console.log(son.__proto__.name); // 张三 // 使用 delete 删除实例的同名属性值 console.log(delete son.name); // true console.log(son.name); // 张三 } 通过hasOwnProperty(属性名)可以判断一个属性存在于构造函数中，还是原型对象中 true表示存在构造函数中；false表示存在原型对象中
console.log(Par.hasOwnProperty(name)); // false 操作符in，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可） window.onload = function () { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name &#43; this.age) } }; var son = new Par(&#39;xm&#39;, &#39;22&#39;) son.year(); console.log(&#39;name&#39; in Par); // true console.log(&#39;age&#39; in Par); // false } 同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样
参考:《对象中是否有某一个属性 in》https://www.cnblogs.com/IwishIcould/p/12333739.html
2.__proto__和 prototype 的区别 prototype属性只有函数对象上才有，而__proto__属性所有对象都有
prototype是由函数对象指向原型对象，而__proto__是由实例指向函数对象的原型对象
原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做原型链
3.继承 原型链继承 优点：父类原型定义的属性和方法可以复用 缺点：子类实例没有自己的属性，不能向父类传递参数
function test1() { function SuperType() { this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ]; this.property = true; } SuperType.prototype = { constructor : SuperType, // 保持构造函数和原型对象的完整性 age : 15, getSuperValue : function() { return this.property; } }; function SonType() { this.property = false; } // 重写子类的原型指向父类的实例：继承父类的原型 SubType.prototype = new SuperType(); SubType.prototype = { constructor : SubType, getSonType : function() { return this.property; } }; // 优点验证 let son = new SubType(); console.log(son.age); // 15 console.log(son.getSuperValue()); // false // 缺点验证 let instance1 = new SubType(); instance1.city.push(&#34;重庆&#34;); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance2 = new SubType(); console.log(instance2.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] } // test1(); 构造函数继承 优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点 缺点：父类原型的属性和方法不可复用
function test2() { function SuperType(name) { this.name = name; this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ] } SuperType.prototype = { constructor : SuperType, age : 18, showInfo : function() { return this.name; } }; function SubType() { // 父类调用 call() 或者 apply() 方法和子类共用同一个 this，实现子类实例属性的继承 SuperType.call(this, &#34;张三&#34;); } // 优点验证 let instance = new SubType(); instance.city.push(&#34;重庆&#34;); console.log(instance.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance1 = new SubType(); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;] // 缺点验证 console.log(instance.age); // undefined instance.showInfo(); // son.showInfo is not a function } // test2(); 组合继承（推荐） 优点：原型的属性和方法可以复用，每个子类实例都有自己的属性 缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖
function test3() { function SuperType(name) { this.name = name; this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ] } SuperType.prototype = { constructor : SuperType, showInfo : function() { console.log(this.name &#43; &#34;今年&#34; &#43; this.age &#43; &#34;岁了&#34;); } }; function SubType(name, age) { // 1. 通过构造方法继承实现实例属性的继承 SuperType.call(this, name); this.age = age; } // 2. 通过原型链继承实现原型方法的继承 SubType.prototype = new SuperType(); // 优点验证 let instance = new SubType(&#34;张三&#34;, 15); instance.showInfo(); // 张三今年 15 岁了 let instance1 = new SubType(); instance1.city.push(&#34;重庆&#34;); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance2 = new SubType(); console.log(instance2.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;] } // test3(); 寄生组合继承（推荐） 优点：解决了组合继承的缺点，效率高 缺点：基本没有
function test4() { function inheritPrototype(subType, superType) { // 1. 继承父类的原型 var prototype = Object.create(superType.prototype); // 2. 重写被污染的 construct prototype.constructor = subType; // 3. 重写子类的原型 subType.prototype = prototype; } function SuperType(name) { this.name = name; this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } // 将父类原型指向子类 inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() { console.log(this.age); } // 优点验证 let instance = new SubType(&#34;张三&#34;, 15); instance.sayName(); // 张三 let instance1 = new SubType(); instance1.city.push(&#34;重庆&#34;); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance2 = new SubType(); console.log(instance2.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;] } // test4(); 4.ES6 新方法－－class 新的关键字class在 es6 开始被引入到 javascript 中来，class的目的就是让定义类更简单
用函数方法实现：
function Person(name) { this.name = name; } Person.prototype.hello = function () { console.log(&#39;Hello, &#39; &#43; this.name &#43; &#39;!&#39;); } var son = new Person(&#39;xm&#39;) son.hello(); // Hello, xm! 用class来实现：
class Person { constructor(name) { this.name = name; } hello() { console.log(&#39;Hello, &#39; &#43; this.name &#43; &#39;!&#39;); } } var son = new person(&#39;xm&#39;) son.hello(); // Hello, xm! 可以在看到，在定义class中，直接包含了构造函数constructor属性，和原型对象上的函数hello()方法，省略掉了function关键字
需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用class可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的
class 继承
用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Person派生一个PrimaryPerson需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：
class PrimaryPerson extends Person { constructor(name, grade) { super(name); // 记得用 super 调用父类的构造方法！ this.grade = grade; } myGrade() { alert(&#39;I am at grade &#39; &#43; this.grade); } } 注意PrimaryPerson的定义也是通过 class 关键字实现的，而extends则表示原型链对象来自Person，子类的构造函数可能会和父类的不太相同
例如，PrimaryPerson需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。
PrimaryPerson已经自动获得了父类Person的hello方法，我们又在子类中定义了新的myGrade方法。
ES6 引入的class和原有的JavaScript原型继承有什么区别呢？
实际上它们没有任何区别，class的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。
但是！
目前并不是所有的浏览器都支持class，所以在选择的时候一定要慎重！
" />
<meta name="description" content="面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
一、什么是面向对象编程 js 是基于原型的，基于面向对象编程
面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类
1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。
自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用
面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。
2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统
面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
想要弄明白面向对象，需要先理解类和对象的概念
《什么是类和对象？》
二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = &#39;小明&#39;; person.age = 22; person.year = function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) }; person.year(); // 字面量 var student = { name: &#39;小明&#39;, age: 22, year: function () { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出：
缺点：重复实例化对象，代码冗余高
2.工厂模式 window.onload = function() { function createObj(name, age) { var obj = new Object(); obj.name = name, obj.age = age, obj.year = function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) } return obj; } var obj = createObj(&#39;小明&#39;, 22); obj.year(); } // 小明今年22岁了！ 优点：解决重复实例化对象的问题 缺点：无法识别对象的类型，因为所有的实例都指向一个原型
3.构造函数 window.onload = function() { function Person(name, age) { this.name = name; this.age = age; this.year = function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) } } var student = new Person(&#39;小明&#39;, 22); student.year(); } // 小明今年22岁了！ 优点：可以识别对象的类型 缺点：多个实例重复创建方法，无法共享
4. 原型模式 window.onload = function() { function Par() {} Par.prototype = { constructor: &#39;Par&#39;, name: &#39;小明&#39;, age: 22, year: function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;) } }; var son = new Par(); son.year(); } // 小明今年22岁了！ 缺点：所有实例共享他的属性和方法，不能传参和初始化属性值
5.混合模式 (推荐使用) 是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值
先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过 prototype 获取，有一个 constructor 属性，可以指向要操作的函数对象（构造函数）
比如constructor: Par，就代表下面这个原型方法指向Par()对象（构造函数）
window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;); } }; var son = new Par(&#39;小明&#39;, 22) son.year(); } // 小明今年22岁了！ 三、原型，原型链 1.原型对象 函数对象都具有prototype属性，它指向函数的原型对象 (浏览器内存创建的对象)，原型对象都具有constructor属性，它指向prototype属性所在的函数对象 (构造函数) window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { // constructor指向对象 constructor: Par, year: function() { console.log(this.name &#43; &#39;今年&#39; &#43; this.age &#43; &#39;岁了！&#39;); } }; var son = new Par(&#39;小明&#39;, 22) son.year(); /*********************************************/ console.log(Par.prototype) console.log(Par.prototype.constructor) /*********************************************/ } 通过控制台可以看到
构造函数的prototypr属性指向原型对象
原型对象的construcyor属性指向构造函数
当调用构造函数创建一个实例后，该实例会有一个隐藏属性__proto__ ，它指向构造函数的原型对象 console.log(son.__proto__ === Par.prototype) // true 所有的构造函数的 prototype 都是 object 类型 console.log(typeof Par.prototype) // object Function 的 prototype 是一个空函数，所有内置函数的__proto__属性都指向这个空函数 console.log(Math.__proto__) 如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过delete方法将同名属性在实例（构造函数）中彻底删除 window.onload = function () { function Par(name) { this.name = name; } Par.prototype.name = &#34;张三&#34;; var son = new Par(&#34;李四&#34;); console.log(son.name); // 李四 console.log(son.__proto__.name); // 张三 // 使用 delete 删除实例的同名属性值 console.log(delete son.name); // true console.log(son.name); // 张三 } 通过hasOwnProperty(属性名)可以判断一个属性存在于构造函数中，还是原型对象中 true表示存在构造函数中；false表示存在原型对象中
console.log(Par.hasOwnProperty(name)); // false 操作符in，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可） window.onload = function () { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name &#43; this.age) } }; var son = new Par(&#39;xm&#39;, &#39;22&#39;) son.year(); console.log(&#39;name&#39; in Par); // true console.log(&#39;age&#39; in Par); // false } 同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样
参考:《对象中是否有某一个属性 in》https://www.cnblogs.com/IwishIcould/p/12333739.html
2.__proto__和 prototype 的区别 prototype属性只有函数对象上才有，而__proto__属性所有对象都有
prototype是由函数对象指向原型对象，而__proto__是由实例指向函数对象的原型对象
原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做原型链
3.继承 原型链继承 优点：父类原型定义的属性和方法可以复用 缺点：子类实例没有自己的属性，不能向父类传递参数
function test1() { function SuperType() { this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ]; this.property = true; } SuperType.prototype = { constructor : SuperType, // 保持构造函数和原型对象的完整性 age : 15, getSuperValue : function() { return this.property; } }; function SonType() { this.property = false; } // 重写子类的原型指向父类的实例：继承父类的原型 SubType.prototype = new SuperType(); SubType.prototype = { constructor : SubType, getSonType : function() { return this.property; } }; // 优点验证 let son = new SubType(); console.log(son.age); // 15 console.log(son.getSuperValue()); // false // 缺点验证 let instance1 = new SubType(); instance1.city.push(&#34;重庆&#34;); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance2 = new SubType(); console.log(instance2.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] } // test1(); 构造函数继承 优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点 缺点：父类原型的属性和方法不可复用
function test2() { function SuperType(name) { this.name = name; this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ] } SuperType.prototype = { constructor : SuperType, age : 18, showInfo : function() { return this.name; } }; function SubType() { // 父类调用 call() 或者 apply() 方法和子类共用同一个 this，实现子类实例属性的继承 SuperType.call(this, &#34;张三&#34;); } // 优点验证 let instance = new SubType(); instance.city.push(&#34;重庆&#34;); console.log(instance.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance1 = new SubType(); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;] // 缺点验证 console.log(instance.age); // undefined instance.showInfo(); // son.showInfo is not a function } // test2(); 组合继承（推荐） 优点：原型的属性和方法可以复用，每个子类实例都有自己的属性 缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖
function test3() { function SuperType(name) { this.name = name; this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ] } SuperType.prototype = { constructor : SuperType, showInfo : function() { console.log(this.name &#43; &#34;今年&#34; &#43; this.age &#43; &#34;岁了&#34;); } }; function SubType(name, age) { // 1. 通过构造方法继承实现实例属性的继承 SuperType.call(this, name); this.age = age; } // 2. 通过原型链继承实现原型方法的继承 SubType.prototype = new SuperType(); // 优点验证 let instance = new SubType(&#34;张三&#34;, 15); instance.showInfo(); // 张三今年 15 岁了 let instance1 = new SubType(); instance1.city.push(&#34;重庆&#34;); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance2 = new SubType(); console.log(instance2.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;] } // test3(); 寄生组合继承（推荐） 优点：解决了组合继承的缺点，效率高 缺点：基本没有
function test4() { function inheritPrototype(subType, superType) { // 1. 继承父类的原型 var prototype = Object.create(superType.prototype); // 2. 重写被污染的 construct prototype.constructor = subType; // 3. 重写子类的原型 subType.prototype = prototype; } function SuperType(name) { this.name = name; this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } // 将父类原型指向子类 inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() { console.log(this.age); } // 优点验证 let instance = new SubType(&#34;张三&#34;, 15); instance.sayName(); // 张三 let instance1 = new SubType(); instance1.city.push(&#34;重庆&#34;); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance2 = new SubType(); console.log(instance2.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;] } // test4(); 4.ES6 新方法－－class 新的关键字class在 es6 开始被引入到 javascript 中来，class的目的就是让定义类更简单
用函数方法实现：
function Person(name) { this.name = name; } Person.prototype.hello = function () { console.log(&#39;Hello, &#39; &#43; this.name &#43; &#39;!&#39;); } var son = new Person(&#39;xm&#39;) son.hello(); // Hello, xm! 用class来实现：
class Person { constructor(name) { this.name = name; } hello() { console.log(&#39;Hello, &#39; &#43; this.name &#43; &#39;!&#39;); } } var son = new person(&#39;xm&#39;) son.hello(); // Hello, xm! 可以在看到，在定义class中，直接包含了构造函数constructor属性，和原型对象上的函数hello()方法，省略掉了function关键字
需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用class可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的
class 继承
用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Person派生一个PrimaryPerson需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：
class PrimaryPerson extends Person { constructor(name, grade) { super(name); // 记得用 super 调用父类的构造方法！ this.grade = grade; } myGrade() { alert(&#39;I am at grade &#39; &#43; this.grade); } } 注意PrimaryPerson的定义也是通过 class 关键字实现的，而extends则表示原型链对象来自Person，子类的构造函数可能会和父类的不太相同
例如，PrimaryPerson需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。
PrimaryPerson已经自动获得了父类Person的hello方法，我们又在子类中定义了新的myGrade方法。
ES6 引入的class和原有的JavaScript原型继承有什么区别呢？
实际上它们没有任何区别，class的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。
但是！
目前并不是所有的浏览器都支持class，所以在选择的时候一定要慎重！
" />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon.ico" />


<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="halo的博客">
</head>

<body>
  <nav class="headnav">
  <a href="http://halo.rebotgpt.top" class="logo">HALO</a>
  <ul id="menu">
    
    <li><a href="/tags/">标签</a></li>
    
    <li><a href="/blog/">博客</a></li>
    
    <li><a href="/message/">留言</a></li>
    
    <li><a href="/search">搜索</a></li>
    
    <li><a href="/index.xml" target="_blank">RSS</a></li>
  </ul>
</nav>
  <section>
    
    <div class="body-title">面向对象编程</div>

    
    <div class="post-meta">
      <time> 2020-11-12</time>
      
      
      <span class="namenode">分类：
        <a href="/categories/%E6%8A%80%E6%9C%AF">技术</a>
      </span>
      
      

      <span class="tag-node">
        
        标签：
        
        <a href="/tags/%E7%BC%96%E7%A8%8B">#编程</a>
        
        <a href="/tags/js">#js</a>
        
        
      </span>

    </div>
    

    
    <div class="toc">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#一什么是面向对象编程">一、什么是面向对象编程</a>
      <ul>
        <li><a href="#1面向过程程序设计">1.面向过程程序设计</a></li>
        <li><a href="#2面向对象程序设计">2.面向对象程序设计</a></li>
      </ul>
    </li>
    <li><a href="#二创建对象的方法">二、创建对象的方法</a>
      <ul>
        <li><a href="#1创建字面量和实例">1.创建字面量和实例</a></li>
        <li><a href="#2工厂模式">2.工厂模式</a></li>
        <li><a href="#3构造函数">3.构造函数</a></li>
        <li><a href="#4-原型模式">4. 原型模式</a></li>
        <li><a href="#5混合模式-推荐使用">5.混合模式 (推荐使用)</a></li>
      </ul>
    </li>
    <li><a href="#三原型原型链">三、原型，原型链</a>
      <ul>
        <li><a href="#1原型对象">1.原型对象</a></li>
        <li><a href="#2__proto__和-prototype-的区别">2.__proto__和 prototype 的区别</a></li>
        <li><a href="#3继承">3.继承</a></li>
        <li><a href="#4es6-新方法class">4.ES6 新方法－－class</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    

    <article class="post-content">
      
      <p>面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。</p>
<h2 id="一什么是面向对象编程">一、什么是面向对象编程</h2>
<p>js 是<code>基于原型</code>的，基于<code>面向对象编程</code></p>
<p>面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类</p>
<h3 id="1面向过程程序设计">1.面向过程程序设计</h3>
<p>将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。</p>
<p>自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用</p>
<p>面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。</p>
<h3 id="2面向对象程序设计">2.面向对象程序设计</h3>
<p>将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统</p>
<p>面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。</p>
<p>想要弄明白面向对象，需要先理解类和对象的概念</p>
<p><a href="../20201118-objects-interfaces-classes">《什么是类和对象？》</a></p>
<h2 id="二创建对象的方法">二、创建对象的方法</h2>
<h3 id="1创建字面量和实例">1.创建字面量和实例</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;小明&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">22</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">person</span><span class="p">.</span><span class="nx">year</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;今年&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">+</span> <span class="s1">&#39;岁了！&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nx">person</span><span class="p">.</span><span class="nx">year</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 字面量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">student</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;小明&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">age</span><span class="o">:</span> <span class="mi">22</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">year</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;今年&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">+</span> <span class="s1">&#39;岁了！&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">student</span><span class="p">.</span><span class="nx">year</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 小明今年22岁了！
</span></span></span></code></pre></div><p>两者输出的结果是一样的，控制台输出：</p>
<blockquote>
<p>缺点：重复实例化对象，代码冗余高</p>
</blockquote>
<h3 id="2工厂模式">2.工厂模式</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">createObj</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nx">obj</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">obj</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">obj</span><span class="p">.</span><span class="nx">year</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;今年&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">+</span> <span class="s1">&#39;岁了！&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">createObj</span><span class="p">(</span><span class="s1">&#39;小明&#39;</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">year</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote>
<p>优点：解决重复实例化对象的问题
缺点：无法识别对象的类型，因为所有的实例都指向一个原型</p>
</blockquote>
<h3 id="3构造函数">3.构造函数</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">year</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;今年&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">+</span> <span class="s1">&#39;岁了！&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">student</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">&#39;小明&#39;</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">student</span><span class="p">.</span><span class="nx">year</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote>
<p>优点：可以识别对象的类型
缺点：多个实例重复创建方法，无法共享</p>
</blockquote>
<h3 id="4-原型模式">4. 原型模式</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">Par</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Par</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">constructor</span><span class="o">:</span> <span class="s1">&#39;Par&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;小明&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">age</span><span class="o">:</span> <span class="mi">22</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">year</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;今年&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">+</span> <span class="s1">&#39;岁了！&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">son</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Par</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">son</span><span class="p">.</span><span class="nx">year</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote>
<p>缺点：所有实例共享他的属性和方法，不能传参和初始化属性值</p>
</blockquote>
<h3 id="5混合模式-推荐使用">5.混合模式 (推荐使用)</h3>
<p>是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值</p>
<p>先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过 prototype 获取，有一个 constructor 属性，可以指向要操作的函数对象（构造函数）</p>
<p>比如<code>constructor: Par</code>，就代表下面这个原型方法指向<code>Par()</code>对象（构造函数）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">Par</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Par</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">constructor</span><span class="o">:</span> <span class="nx">Par</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">year</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;今年&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">+</span> <span class="s1">&#39;岁了！&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">son</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Par</span><span class="p">(</span><span class="s1">&#39;小明&#39;</span><span class="p">,</span> <span class="mi">22</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">son</span><span class="p">.</span><span class="nx">year</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 小明今年22岁了！
</span></span></span></code></pre></div><h2 id="三原型原型链">三、原型，原型链</h2>
<h3 id="1原型对象">1.原型对象</h3>
<ol>
<li>函数对象都具有<code>prototype</code>属性，它指向函数的原型对象 (浏览器内存创建的对象)，原型对象都具有<code>constructor</code>属性，它指向<code>prototype</code>属性所在的函数对象 (构造函数)</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">Par</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Par</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// constructor指向对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">constructor</span><span class="o">:</span> <span class="nx">Par</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">year</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;今年&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">+</span> <span class="s1">&#39;岁了！&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">son</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Par</span><span class="p">(</span><span class="s1">&#39;小明&#39;</span><span class="p">,</span> <span class="mi">22</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">son</span><span class="p">.</span><span class="nx">year</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*********************************************/</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Par</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Par</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cm">/*********************************************/</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>通过控制台可以看到</p>
<p>构造函数的<code>prototypr</code>属性指向原型对象</p>
<p>原型对象的<code>construcyor</code>属性指向构造函数</p>
<ol>
<li>当调用构造函数创建一个实例后，该实例会有一个隐藏属性<code>__proto__ </code>，它指向构造函数的原型对象</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">son</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Par</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div><ol start="3">
<li>所有的构造函数的 prototype 都是 object 类型</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">Par</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// object
</span></span></span></code></pre></div><ol start="4">
<li>Function 的 prototype 是一个空函数，所有内置函数的__proto__属性都指向这个空函数</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">)</span>
</span></span></code></pre></div><ol>
<li>如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过<code>delete</code>方法将同名属性在实例（构造函数）中彻底删除</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">Par</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Par</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;张三&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">son</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Par</span><span class="p">(</span><span class="s2">&#34;李四&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">son</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 李四
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">son</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 张三
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用 delete 删除实例的同名属性值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">delete</span> <span class="nx">son</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>   <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">son</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 张三
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="6">
<li>通过<code>hasOwnProperty(属性名)</code>可以判断一个属性存在于构造函数中，还是原型对象中</li>
</ol>
<blockquote>
<p><code>true</code>表示存在构造函数中；<code>false</code>表示存在原型对象中</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Par</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">name</span><span class="p">));</span>  <span class="c1">// false
</span></span></span></code></pre></div><ol start="7">
<li>操作符<code>in</code>，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可）</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">Par</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Par</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">constructor</span><span class="o">:</span> <span class="nx">Par</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">year</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">son</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Par</span><span class="p">(</span><span class="s1">&#39;xm&#39;</span><span class="p">,</span> <span class="s1">&#39;22&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">son</span><span class="p">.</span><span class="nx">year</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;name&#39;</span> <span class="k">in</span> <span class="nx">Par</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;age&#39;</span> <span class="k">in</span> <span class="nx">Par</span><span class="p">);</span>  <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样</p>
<blockquote>
<p>参考:《对象中是否有某一个属性 in》<a href="https://www.cnblogs.com/IwishIcould/p/12333739.html">https://www.cnblogs.com/IwishIcould/p/12333739.html</a></p>
</blockquote>
<h3 id="2__proto__和-prototype-的区别">2.__proto__和 prototype 的区别</h3>
<ol>
<li>
<p><code>prototype</code>属性只有函数对象上才有，而<code>__proto__</code>属性所有对象都有</p>
</li>
<li>
<p><code>prototype</code>是由函数对象指向原型对象，而<code>__proto__</code>是由实例指向函数对象的原型对象</p>
</li>
<li>
<p>原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做<code>原型链</code></p>
</li>
</ol>
<h3 id="3继承">3.继承</h3>
<ol>
<li>原型链继承</li>
</ol>
<blockquote>
<p>优点：父类原型定义的属性和方法可以复用
缺点：子类实例没有自己的属性，不能向父类传递参数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">test1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">SuperType</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">city</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&#34;北京&#34;</span><span class="p">,</span> <span class="s2">&#34;上海&#34;</span><span class="p">,</span> <span class="s2">&#34;天津&#34;</span> <span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">property</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">constructor</span> <span class="o">:</span> <span class="nx">SuperType</span><span class="p">,</span>     <span class="c1">// 保持构造函数和原型对象的完整性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">age</span> <span class="o">:</span> <span class="mi">15</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">getSuperValue</span> <span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">SonType</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">property</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 重写子类的原型指向父类的实例：继承父类的原型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">constructor</span> <span class="o">:</span> <span class="nx">SubType</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">getSonType</span> <span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 优点验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">son</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">son</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// 15
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">son</span><span class="p">.</span><span class="nx">getSuperValue</span><span class="p">());</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 缺点验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">instance1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">instance1</span><span class="p">.</span><span class="nx">city</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;重庆&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance1</span><span class="p">.</span><span class="nx">city</span><span class="p">);</span> <span class="c1">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">instance2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance2</span><span class="p">.</span><span class="nx">city</span><span class="p">);</span> <span class="c1">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// test1();
</span></span></span></code></pre></div><ol start="2">
<li>构造函数继承</li>
</ol>
<blockquote>
<p>优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点
缺点：父类原型的属性和方法不可复用</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">test2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">city</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&#34;北京&#34;</span><span class="p">,</span> <span class="s2">&#34;上海&#34;</span><span class="p">,</span> <span class="s2">&#34;天津&#34;</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">constructor</span> <span class="o">:</span> <span class="nx">SuperType</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">age</span> <span class="o">:</span> <span class="mi">18</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">showInfo</span> <span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">SubType</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 父类调用 call() 或者 apply() 方法和子类共用同一个 this，实现子类实例属性的继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">SuperType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s2">&#34;张三&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 优点验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">instance</span><span class="p">.</span><span class="nx">city</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;重庆&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">city</span><span class="p">);</span> <span class="c1">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">instance1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance1</span><span class="p">.</span><span class="nx">city</span><span class="p">);</span> <span class="c1">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 缺点验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">instance</span><span class="p">.</span><span class="nx">showInfo</span><span class="p">();</span> <span class="c1">// son.showInfo is not a function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// test2();
</span></span></span></code></pre></div><ol start="3">
<li>组合继承（推荐）</li>
</ol>
<blockquote>
<p>优点：原型的属性和方法可以复用，每个子类实例都有自己的属性
缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">test3</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">city</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&#34;北京&#34;</span><span class="p">,</span> <span class="s2">&#34;上海&#34;</span><span class="p">,</span> <span class="s2">&#34;天津&#34;</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">constructor</span> <span class="o">:</span> <span class="nx">SuperType</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">showInfo</span> <span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">&#34;今年&#34;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">+</span> <span class="s2">&#34;岁了&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">SubType</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 通过构造方法继承实现实例属性的继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">SuperType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 通过原型链继承实现原型方法的继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 优点验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">(</span><span class="s2">&#34;张三&#34;</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">instance</span><span class="p">.</span><span class="nx">showInfo</span><span class="p">();</span> <span class="c1">// 张三今年 15 岁了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">instance1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">instance1</span><span class="p">.</span><span class="nx">city</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;重庆&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance1</span><span class="p">.</span><span class="nx">city</span><span class="p">);</span> <span class="c1">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">instance2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance2</span><span class="p">.</span><span class="nx">city</span><span class="p">);</span> <span class="c1">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// test3();
</span></span></span></code></pre></div><ol start="4">
<li>寄生组合继承（推荐）</li>
</ol>
<blockquote>
<p>优点：解决了组合继承的缺点，效率高
缺点：基本没有</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">test4</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">inheritPrototype</span><span class="p">(</span><span class="nx">subType</span><span class="p">,</span> <span class="nx">superType</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 继承父类的原型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">var</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">superType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 重写被污染的 construct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">subType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 重写子类的原型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">subType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">prototype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">city</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&#34;北京&#34;</span><span class="p">,</span> <span class="s2">&#34;上海&#34;</span><span class="p">,</span> <span class="s2">&#34;天津&#34;</span> <span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">SubType</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">SuperType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将父类原型指向子类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">inheritPrototype</span><span class="p">(</span><span class="nx">SubType</span><span class="p">,</span> <span class="nx">SuperType</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayAge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 优点验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">(</span><span class="s2">&#34;张三&#34;</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">instance</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">// 张三
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">instance1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">instance1</span><span class="p">.</span><span class="nx">city</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;重庆&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance1</span><span class="p">.</span><span class="nx">city</span><span class="p">);</span> <span class="c1">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">instance2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance2</span><span class="p">.</span><span class="nx">city</span><span class="p">);</span> <span class="c1">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// test4();
</span></span></span></code></pre></div><h3 id="4es6-新方法class">4.ES6 新方法－－class</h3>
<p>新的关键字<code>class</code>在 es6 开始被引入到 javascript 中来，<code>class</code>的目的就是让定义类更简单</p>
<p>用函数方法实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello, &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">son</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">&#39;xm&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">son</span><span class="p">.</span><span class="nx">hello</span><span class="p">();</span>    <span class="c1">// Hello, xm!
</span></span></span></code></pre></div><p>用<code>class</code>来实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello, &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">son</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">person</span><span class="p">(</span><span class="s1">&#39;xm&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">son</span><span class="p">.</span><span class="nx">hello</span><span class="p">();</span>    <span class="c1">// Hello, xm!
</span></span></span></code></pre></div><p>可以在看到，在定义<code>class</code>中，直接包含了构造函数<code>constructor</code>属性，和原型对象上的函数<code>hello()</code>方法，省略掉了<code>function</code>关键字</p>
<p>需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用<code>class</code>可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的</p>
<p><strong>class 继承</strong></p>
<p>用<code>class</code>定义对象的另一个巨大的好处是继承更方便了。想一想我们从<code>Person</code>派生一个<code>PrimaryPerson</code>需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过<code>extends</code>来实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">PrimaryPerson</span> <span class="kr">extends</span> <span class="nx">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">grade</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">super</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 记得用 super 调用父类的构造方法！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">grade</span> <span class="o">=</span> <span class="nx">grade</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">myGrade</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;I am at grade &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">grade</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意<code>PrimaryPerson</code>的定义也是通过 class 关键字实现的，而<code>extends</code>则表示原型链对象来自<code>Person</code>，子类的构造函数可能会和父类的不太相同</p>
<p>例如，<code>PrimaryPerson</code>需要<code>name</code>和<code>grade</code>两个参数，并且需要通过<code>super(name)</code>来调用父类的构造函数，否则父类的<code>name</code>属性无法正常初始化。</p>
<p><code>PrimaryPerson</code>已经自动获得了父类<code>Person</code>的<code>hello方法</code>，我们又在子类中定义了新的<code>myGrade</code>方法。</p>
<p>ES6 引入的<code>class</code>和原有的<code>JavaScript原型继承</code>有什么区别呢？</p>
<p>实际上它们没有任何区别，<code>class</code>的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用<code>class</code>的好处就是极大地简化了原型链代码。</p>
<p>但是！</p>
<p>目前并不是所有的浏览器都支持<code>class</code>，所以在选择的时候一定要慎重！</p>

    </article>

    
    <div class="comments">
  <div class="giscus"></div>
</div>
<script src="https://giscus.app/client.js"
        data-repo="yangdinghui/hugo-blog"
        data-repo-id="R_kgDOM_kHsQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOM_kHsc4CjUf7"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

    
    
  </section>
  <footer class="footer">
  <p>© 2020 - 2024 Powered by
    <a href="https://github.com/yangdinghui" target="_blank">Github</a>
    / <a href="/index.xml" target="_blank">RSS</a>
  </p>
</footer>


</body>

</html>